# 1 代码说明

一棵可以构造10W叶子节点的Merkle Tree。采用动态数组申请。根据RFC文档编写。附带审计路径查找函数和（不）存在性函数。SM3为手写。

这棵树是一次性构造，但是在构造过程中，已经模拟了增加节点的过程。

# 2 运行指导

- 复制文件到工程中，运行main函数。现在介绍三个函数：用于构造merkle树的build函数；审计路径查找函数map函数；查找节点是否存在的mcproof函数。

  在main函数中，请输入叶子节点的个数n；随后输入n个叶子节点的值。值的格式是十六进制小写字符串
  
  这棵树的所有节点用数组存储，每个数组元素是一个结构体。
  
  - 调用build函数
  
  在得知n和叶节点的值后，就可调用，如下：
  
  s = build(0, n-1, (n-1) / 2, 0); 
  
  s为根节点的SM3 hash值，第一个参数为0，代表根节点，第二个参数为最后一个叶子节点，为n-1，第三个为中位数，计算方式：(0+n-1)/2,第四个参数为0，用于递归时寻找右孩子编号。
  
  然后，会输出叶节点在树中对应的标号，这个标号非常重要，在审计路径和存在性证明中，都需要输入标号。
  
  - 使用map函数进行审计路径操作
  
  输入某个叶子节点在树中的标号（注意看上面一行写的）。map结束后会在mapath数组里存储审计路径，可以输出查看。
  
  - 最后是mcproof函数
  
    bool mcproof(string value,long long idx , long long broidx[]);
  
    输入查找在不在树中的“值”，这个值会被计算hash用于查找在不在树中。对于idx，请输入该值可能位于的叶子节点的标号，不要瞎猜，要找他最有可能出现的节点，即使猜错了也要输入，因为要用idx计算它是左节点还是右节点。最后是你已知的审计路径数组。
  

# 3 过程截图

  首先我们查看代码，便于观察函数的调用：
  
  ![image](https://raw.githubusercontent.com/Pozsk209/automatic-octo-tribble/main/pic/MT1.PNG)
  
  函数首先输入叶节点个数n，并按序输入每个节点的值，注意，值的格式是十六进制小写字符串。
  
  此处输入n=8, 叶节点按照顺序为61，62，63，64，65，66，68，67
  
  然后调用build函数进行merkle树一次性构造。 具体参数意义上文已经给出。
  
  trans数组保存了叶子节点在树中的标号。
  
  map输入的时候需要使用标号输入，截图中的map(14)意义上等同于map(trans[7]);
  
  mcproof 审查值是否在树中。
  
  以下是输入和结果展示
  
  ![image](https://raw.githubusercontent.com/Pozsk209/automatic-octo-tribble/main/pic/MT2.PNG)

  
